<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>HackTheVote.exe</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
  *{box-sizing:border-box;margin:0;padding:0}
  body{
    font-family:'Press Start 2P',cursive;
    background:#000;color:#00ff00;min-height:100vh;display:flex;flex-direction:column;
  }
  header{display:flex;flex-wrap:wrap;align-items:center;padding:18px;border-bottom:3px solid #00ff00;background:rgba(0,0,0,0.9)}
  header img{height:72px;margin-right:18px}
  .tagline{font-size:12px;color:#66ff66;width:100%;margin-top:6px}
  main{width:95%;max-width:1200px;margin:18px auto;display:flex;flex-direction:column;gap:22px}
  .vision,.vote-section,.vault-section,.chat-section{border:2px solid #00ff00;padding:18px;border-radius:8px;background:#001100}
  .vision h2{margin-bottom:8px}
  .vision p{font-size:12px;color:#66ff66}
  .vote-buttons{display:flex;flex-wrap:wrap;gap:12px;margin-top:12px}
  .vote-btn{flex:1 1 45%;min-width:120px;background:#000;color:#00ff00;border:2px solid #00ff00;padding:12px;border-radius:8px;cursor:pointer;position:relative}
  .vote-btn:hover{background:#00ff00;color:#000}
  .vote-count{position:absolute;top:6px;right:10px;font-size:10px;color:#66ff66}
  .timer{margin-top:12px;font-size:14px;color:#66ff66}
  .reactor-bar{width:100%;background:#003300;height:26px;margin-top:14px;border:2px solid #00ff00;border-radius:6px}
  .reactor-fill{height:100%;width:0;background:#00ff00;border-radius:6px;transition:width .5s ease-in-out}
  .vault-list{max-height:220px;overflow:auto;padding:10px;background:#002200;border:2px solid #00ff00;border-radius:6px}
  .chat-messages{flex:1;max-height:360px;overflow:auto;padding:10px;background:#002200;border:2px solid #00ff00;border-radius:6px;margin-bottom:10px}
  .chat-input-container{display:flex;gap:10px}
  .chat-input{flex:1;padding:10px;background:#000;color:#00ff00;border:2px solid #00ff00;border-radius:6px}
  .chat-send{padding:10px 16px;background:#000;color:#00ff00;border:2px solid #00ff00;border-radius:6px;cursor:pointer}
  footer{text-align:center;padding:16px;border-top:3px solid #00ff00;background:rgba(0,0,0,0.9)}
  @media(max-width:768px){.vote-btn{flex:1 1 100%}.chat-messages{max-height:240px}}
  /* winner reveal overlay */
  #winnerOverlay{position:fixed;inset:0;background:rgba(0,0,0,0.95);display:none;align-items:center;justify-content:center;z-index:9999;flex-direction:column}
  #winnerOverlay .box{border:3px solid #00ff00;padding:30px;border-radius:12px;background:#001100;text-align:center}
  #winnerOverlay h2{font-size:20px;margin-bottom:12px}
  #winnerOverlay p{color:#66ff66;margin-bottom:12px}
</style>
</head>
<body>

<header>
  <img src="hackthevote-logo.png" alt="HackTheVote.exe logo">
  <div>
    <h1>HackTheVote.exe</h1>
    <div class="tagline">Every vote counts. Every choice matters.</div>
  </div>
</header>

<main>
  <!-- Vision -->
  <section class="vision">
    <h2>HackTheVote.exe — The Meme Coin Where the Community Controls the Power</h2>
    <p>Every 6 hours, the community decides how creator rewards are spent: boosts, buybacks, giveaways, or charity. Your vote is real, live, and visible in the Vault of Decisions. Join the revolution — your voice shapes the future of HackTheVote.exe.</p>
  </section>

  <!-- Voting -->
  <section class="vote-section">
    <h2>Vote Now</h2>
    <p>Vote options may change daily — it's up to the community to decide how creator rewards are spent!</p>

    <div class="vote-buttons" id="voteButtons">
      <!-- Buttons generated by JS -->
    </div>

    <div class="timer" id="voteTimer">Voting ends in: --:--:--</div>
    <div class="timer" id="phaseTimer" style="display:none">Reveal ends in: --:--:--</div>

    <div class="reactor-bar"><div class="reactor-fill" id="reactorFill"></div></div>
  </section>

  <!-- Vault -->
  <section class="vault-section">
    <h2>Vault of Decisions</h2>
    <div class="vault-list" id="vaultList"><p>No past decisions yet.</p></div>
  </section>

  <!-- Chat -->
  <section class="chat-section">
    <h2>Community Chat</h2>
    <div class="chat-messages" id="chatMessages"></div>
    <div class="chat-input-container">
      <input type="text" id="chatInput" class="chat-input" maxlength="200" placeholder="Type a message...">
      <button class="chat-send" id="chatSendBtn">Send</button>
    </div>
  </section>
</main>

<footer>&copy; 2025 HackTheVote.exe — Your vote shapes the future</footer>

<!-- Winner overlay -->
<div id="winnerOverlay">
  <div class="box">
    <h2 id="winnerTitle">The People Have Spoken — Decision Confirmed</h2>
    <p id="winnerText"></p>
    <div id="winnerCountdown" class="timer"></div>
    <button onclick="closeWinner()" style="margin-top:10px;padding:10px;border:2px solid #00ff00;background:#000;color:#00ff00;border-radius:6px;cursor:pointer">Close</button>
  </div>
</div>

<!-- Firebase compat libs -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

<script>
/* ==========================
   CONFIG - your Firebase config
   ========================== */
const firebaseConfig = {
  apiKey: "AIzaSyDtZn9TgH6GYIy4e0-JUURx8eTCsLTvuBg",
  authDomain: "hackthevoteexe.firebaseapp.com",
  projectId: "hackthevoteexe",
  storageBucket: "hackthevoteexe.firebasestorage.app",
  messagingSenderId: "761143046917",
  appId: "1:761143046917:web:48f82496c2959add0ffd6c",
  databaseURL: "https://hackthevoteexe-default-rtdb.firebaseio.com/"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

/* ==========================
   Settings
   ========================== */
const VOTE_OPTIONS = [
  "Buybacks & Burns",
  "Giveaways",
  "Boosts",
  "Donate to Good Causes"
];
const VOTE_WINDOW_MS = 6 * 60 * 60 * 1000; // 6 hours voting
const REVEAL_WINDOW_MS = 1 * 60 * 60 * 1000; // 1 hour reveal
const CYCLE_MS = VOTE_WINDOW_MS + REVEAL_WINDOW_MS;
const MAX_VOTES_PER_IP = 4;
const IP_CHECK_URL = "https://api.ipify.org?format=json"; // used to get user's public IP

/* ==========================
   Helpers
   ========================== */
function safeKey(str){
  // convert option string to a safe Firebase key
  return encodeURIComponent(str);
}
function fmtTime(ms){
  const hrs = Math.floor(ms/3600000);
  const mins = Math.floor((ms%3600000)/60000);
  const secs = Math.floor((ms%60000)/1000);
  return `${String(hrs).padStart(2,"0")}:${String(mins).padStart(2,"0")}:${String(secs).padStart(2,"0")}`;
}

/* ==========================
   Initial setup: create buttons (and placeholders)
   ========================== */
const voteButtonsEl = document.getElementById("voteButtons");
VOTE_OPTIONS.forEach(opt=>{
  const btn = document.createElement("button");
  btn.className = "vote-btn";
  btn.dataset.opt = opt;
  btn.innerText = opt;
  const span = document.createElement("span");
  span.className = "vote-count";
  span.id = `count-${safeKey(opt)}`;
  span.innerText = "0";
  btn.appendChild(span);
  btn.addEventListener("click", ()=> attemptVote(opt, btn));
  voteButtonsEl.appendChild(btn);
});

/* ==========================
   Globals tracked client-side
   ========================== */
let clientIP = null;
let currentVoteStart = null; // timestamp in ms (stored in Firebase)
let votePhase = "loading"; // "voting", "reveal"
let voteCounts = {}; // latest counts

/* ==========================
   Get IP for per-IP limits
   ========================== */
async function fetchClientIP(){
  try{
    const r = await fetch(IP_CHECK_URL);
    const j = await r.json();
    clientIP = j.ip.replace(/\./g, "-"); // replace dots to use as key
  }catch(e){
    console.warn("Could not fetch IP. Vote limiting will use localStorage fallback.", e);
    clientIP = null;
  }
}

/* ==========================
   Ensure DB has initial structure
   ========================== */
async function ensureDbSetup(){
  const root = db.ref();
  // initialize votes node if missing
  const votesSnap = await db.ref("votes").once("value");
  if(!votesSnap.exists()){
    const initObj = {};
    VOTE_OPTIONS.forEach(o=> initObj[safeKey(o)] = 0);
    await db.ref("votes").set(initObj);
  }
  // ensure voteStart exists (use transaction to avoid race)
  await db.ref("voteStart").transaction(current=>{
    if(current === null){
      // align to floor(current time / CYCLE) * CYCLE so cycles are consistent
      return Date.now();
    }
    return; // leave existing
  });
}

/* ==========================
   Listen for vote counts & update UI
   ========================== */
db.ref("votes").on("value", snapshot=>{
  const data = snapshot.val() || {};
  voteCounts = data;
  // update UI
  let total = 0;
  VOTE_OPTIONS.forEach(opt=>{
    const key = safeKey(opt);
    const count = Number(data[key] || 0);
    document.getElementById(`count-${key}`).innerText = count;
    total += count;
  });
  // update reactor fill (scale: clamp total*5 to 100)
  const pct = Math.min(100, total * 5);
  document.getElementById("reactorFill").style.width = pct + "%";
});

/* ==========================
   Listen for voteStart changes to sync timers & phases
   ========================== */
db.ref("voteStart").on("value", snapshot=>{
  const ts = snapshot.val();
  if(!ts) return;
  currentVoteStart = Number(ts);
  updatePhaseAndTimers();
});

/* ==========================
   update phase/timers display
   ========================== */
let timersInterval = null;
function updatePhaseAndTimers(){
  if(timersInterval) clearInterval(timersInterval);
  function tick(){
    const now = Date.now();
    // compute which cycle we are in relative to currentVoteStart
    let start = Number(currentVoteStart);
    // If the stored start is in the future (unlikely) set it to now
    if(start > now) start = now;
    // compute cycles passed
    const diff = now - start;
    const cyclesPassed = Math.floor(diff / CYCLE_MS);
    const cycleStart = start + cyclesPassed * CYCLE_MS;
    const voteWindowStart = cycleStart;
    const voteWindowEnd = cycleStart + VOTE_WINDOW_MS;
    const revealEnd = cycleStart + CYCLE_MS;

    if(now < voteWindowEnd){
      votePhase = "voting";
      const remaining = voteWindowEnd - now;
      document.getElementById("voteTimer").textContent = "Voting ends in: " + fmtTime(remaining);
      document.getElementById("voteTimer").style.display = "block";
      document.getElementById("phaseTimer").style.display = "none";
      // enable buttons
      document.querySelectorAll(".vote-btn").forEach(b=> b.disabled = false);
    } else if(now >= voteWindowEnd && now < revealEnd){
      votePhase = "reveal";
      const remaining = revealEnd - now;
      document.getElementById("phaseTimer").textContent = "Reveal ends in: " + fmtTime(remaining);
      document.getElementById("phaseTimer").style.display = "block";
      document.getElementById("voteTimer").style.display = "none";
      // disable buttons
      document.querySelectorAll(".vote-btn").forEach(b=> b.disabled = true);
      // if reveal just started, trigger winner logic once
      // detect reveal start by checking if cyclesPassed changed since last tick
      handleRevealCycle(cycleStart, voteWindowEnd);
    } else {
      // after reveal end - should rarely hit here because cyclesPassed would be advanced
      votePhase = "voting";
      document.getElementById("voteTimer").textContent = "Voting ends in: --:--:--";
      document.getElementById("phaseTimer").style.display = "none";
      document.querySelectorAll(".vote-btn").forEach(b=> b.disabled = false);
    }
  }
  tick();
  timersInterval = setInterval(tick, 1000);
}

/* ==========================
   Reveal logic: detect reveal start and push winner to vault
   - We store lastRevealAt in DB to avoid duplicate processing
   ========================== */
let lastHandledRevealCycleStart = null;
async function handleRevealCycle(cycleStart, voteWindowEnd){
  // Reveal started when now >= voteWindowEnd and < voteWindowEnd + reveal
  // We'll store 'lastRevealAt' in DB keyed by cycleStart to ensure idempotent processing
  const revealKey = `reveal_${cycleStart}`;
  // Check if we already processed
  const snap = await db.ref("reveals/" + revealKey).once("value");
  if(snap.exists()) return; // already processed
  // Wait a small delay to ensure last votes settle
  setTimeout(async ()=>{
    // calculate winner
    const votesSnap = await db.ref("votes").once("value");
    const votes = votesSnap.val() || {};
    // find highest
    let winner = null;
    let maxVotes = -1;
    for(const opt of VOTE_OPTIONS){
      const key = safeKey(opt);
      const c = Number(votes[key] || 0);
      if(c > maxVotes){ winner = opt; maxVotes = c; }
    }
    // store in vault with timestamp and counts snapshot
    const vaultEntry = {
      winner: winner || "No votes",
      counts: votes,
      timestamp: Date.now(),
      cycleStart: cycleStart
    };
    await db.ref("vault").push(vaultEntry);
    // mark reveal processed
    await db.ref("reveals/" + revealKey).set({ processedAt: Date.now() });
    // show overlay to everyone (UI will listen for vault changes and you can show last pushed)
    showWinnerOverlay(vaultEntry);
    // reset votes for next cycle (we will zero votes only AFTER reveal)
    // IMPORTANT: Use transaction to avoid race if new votes appear (they should be blocked because voting disabled)
    const resetObj = {};
    VOTE_OPTIONS.forEach(o => resetObj[safeKey(o)] = 0);
    await db.ref("votes").set(resetObj);
    // Optionally update voteStart to the next cycle start in DB if cycles drift
    // compute next cycle start aligned to current cycleStart + CYCLE_MS
    await db.ref("voteStart").transaction(curr=>{
      if(curr === null) return Date.now();
      // if curr equals the cycleStart we processed, advance it by CYCLE_MS
      if(Number(curr) === Number(cycleStart)){
        return Number(curr) + CYCLE_MS;
      }
      return; // someone else already updated
    });
  }, 1500);
}

/* ==========================
   Winner overlay UI
   ========================== */
function showWinnerOverlay(vaultEntry){
  const o = document.getElementById("winnerOverlay");
  document.getElementById("winnerText").innerText = `Winner: ${vaultEntry.winner}\nVotes: ${JSON.stringify(vaultEntry.counts)}`;
  // show reveal timer for 1 hour
  const revealEnd = vaultEntry.cycleStart + CYCLE_MS;
  function tick(){
    const rem = revealEnd - Date.now();
    if(rem <= 0){
      document.getElementById("winnerCountdown").innerText = "Reveal ended";
      clearInterval(winInt);
    } else {
      document.getElementById("winnerCountdown").innerText = "Reveal ends in: " + fmtTime(rem);
    }
  }
  tick();
  const winInt = setInterval(tick,1000);
  o.style.display = "flex";
}
function closeWinner(){
  document.getElementById("winnerOverlay").style.display = "none";
}

/* ==========================
   Voting attempt flow:
   - get client IP if unknown
   - check ipVotes/{ip}/{cycleStart} counter
   - if less than MAX, push vote via transaction to votes/{option} and increment ipVotes
   ========================== */
async function attemptVote(option, buttonEl){
  if(votePhase !== "voting"){
    alert("Voting is currently closed. Wait for the next voting window.");
    return;
  }
  // ensure client IP loaded
  if(clientIP === null) await fetchClientIP();
  // determine current aligned cycleStart
  const now = Date.now();
  // read the canonical voteStart from DB to compute cycleStart
  const vsnap = await db.ref("voteStart").once("value");
  const start = Number(vsnap.val() || Date.now());
  const cyclesPassed = Math.floor((now - start) / CYCLE_MS);
  const cycleStart = start + cyclesPassed * CYCLE_MS;

  const ipKey = clientIP ? clientIP : "unknown-" + (localStorage.getItem("anonId") || (()=>{const id='anon-'+Math.random().toString(36).slice(2,9); localStorage.setItem('anonId',id); return id;})());
  const ipVotesRef = db.ref(`ipVotes/${ipKey}/${cycleStart}`);
  // transaction on ipVotes to ensure consistency
  try{
    const result = await ipVotesRef.transaction(current=>{
      if(current === null) return 1;
      return Number(current) + 1;
    });
    if(!result.committed){
      // fallback
      alert("Could not register vote. Try again.");
      return;
    }
    const newCount = result.snapshot.val();
    if(newCount > MAX_VOTES_PER_IP){
      // revert increment: decrement back by 1
      await ipVotesRef.transaction(curr => Math.max(0, (curr || 0) - 1) );
      alert(`Vote limit reached for your IP. Max ${MAX_VOTES_PER_IP} votes per ${VOTE_WINDOW_MS/(60*60*1000)} hours.`);
      return;
    }
    // safe: increment the vote count for option using transaction
    const optKey = safeKey(option);
    await db.ref(`votes/${optKey}`).transaction(curr => (curr || 0) + 1);
    // play sound (free clip)
    try{ new Audio('https://freesound.org/data/previews/256/256113_3263906-lq.mp3').play(); }catch(e){}
  }catch(e){
    console.error("Error during vote attempt:", e);
    alert("There was an error submitting your vote. Try again in a moment.");
  }
}

/* ==========================
   Chat: push messages with basic rate limiting (client-side)
   ========================== */
const chatRef = db.ref("chat");
let lastChatAt = 0;
const CHAT_RATE_LIMIT_MS = 8000; // 8 seconds between messages from same client
document.getElementById("chatSendBtn").addEventListener("click", sendChat);
document.getElementById("chatInput").addEventListener("keydown", (e)=>{ if(e.key === "Enter") sendChat(); });

async function sendChat(){
  const input = document.getElementById("chatInput");
  const text = input.value.trim();
  if(!text) return;
  const now = Date.now();
  if(now - lastChatAt < CHAT_RATE_LIMIT_MS){
    alert("Slow down — chat is rate-limited to prevent spam.");
    return;
  }
  lastChatAt = now;
  // push message with minimal metadata
  const payload = {
    text: text,
    ts: now
  };
  try{
    await chatRef.push(payload);
    try{ new Audio('https://freesound.org/data/previews/256/256113_3263906-lq.mp3').play(); }catch(e){}
    input.value = "";
  }catch(e){
    console.error("Chat send error:", e);
    alert("Could not send chat. Try again.");
  }
}

/* ==========================
   Listen to chat messages and render
   ========================== */
chatRef.limitToLast(200).on("child_added", snap=>{
  const m = snap.val();
  const el = document.createElement("div");
  el.style.padding = "6px 0";
  el.style.borderBottom = "1px dashed rgba(0,255,0,0.06)";
  el.innerText = `[${new Date(m.ts).toLocaleTimeString()}] ${m.text}`;
  document.getElementById("chatMessages").appendChild(el);
  document.getElementById("chatMessages").scrollTop = document.getElementById("chatMessages").scrollHeight;
});

/* ==========================
   Vault rendering
   ========================== */
db.ref("vault").limitToLast(50).on("value", snap=>{
  const list = document.getElementById("vaultList");
  list.innerHTML = "";
  const val = snap.val();
  if(!val){
    list.innerHTML = "<p>No past decisions yet.</p>";
    return;
  }
  const entries = Object.values(val).sort((a,b)=> b.timestamp - a.timestamp);
  entries.forEach(e=>{
    const el = document.createElement("div");
    el.style.padding="8px";
    el.style.borderBottom="1px dashed rgba(0,255,0,0.06)";
    const d = new Date(e.timestamp);
    el.innerHTML = `<div style="font-size:12px;color:#66ff66">${d.toLocaleString()} — Winner: ${e.winner}</div>
                    <div style="font-size:11px;color:#99ff99">Counts: ${Object.entries(e.counts||{}).map(kv=> `${decodeURIComponent(kv[0])}:${kv[1]}`).join(", ")}</div>`;
    list.appendChild(el);
  });
});

/* ==========================
   Startup: fetch IP, ensure DB setup, then start
   ========================== */
(async function init(){
  await fetchClientIP();
  await ensureDbSetup();
  // set up voteStart listener already above
  // also ensure the votes UI displays current counts (handled by 'votes' listener)
  console.log("HackTheVote client ready.");
})();

</script>
</body>
</html>